apply plugin: 'java'
apply plugin: 'distribution'

sourceCompatibility = '1.8'
[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'

import groovy.util.XmlParser
import groovy.xml.XmlUtil
import org.gradle.api.internal.file.copy.CopySpecInternal

def packageXMLTemplate =
'''<?xml version="1.0" encoding="utf-8" ?>
<package xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.mendix.com/package/1.0/">
    <modelerProject xmlns="http://www.mendix.com/modelerProject/1.0/">
        <module name="''' + "${project.name}" + '''" />
        <projectFile path="''' + "${project.name}.mpr" + '''" />
        <files/>
    </modelerProject>
</package>'''

//def runtimeLibs = 'D:/Program Files/Mendix/7.11.0/runtime/bundles'
def runtimeLibs = '/home/reinout/Mendix/mxbuild-7.11.0/runtime/bundles'
def userLibDir = "$projectDir/src/CommunityCommons/userlib"
def version = '6.4.0'

// NetBeans will automatically add "run" and "debug" tasks relying on the
// "mainClass" property. You may however define the property prior executing
// tasks by passing a "-PmainClass=<QUALIFIED_CLASS_NAME>" argument.
//
// Note however, that you may define your own "run" and "debug" task if you
// prefer. In this case NetBeans will not add these tasks but you may rely on
// your own implementation.
if (!hasProperty('mainClass')) {
    ext.mainClass = 'com.mendix.communitycommons.Main'
}

repositories {
    mavenCentral()
}

dependencies {
    testCompile group: 'junit', name: 'junit', version: '4.12'
    compile group: 'org.owasp.antisamy', name: 'antisamy', version: '1.5.3'
    compile group: 'commons-io', name: 'commons-io', version: '2.6'
    compile group: 'org.apache.pdfbox', name: 'pdfbox', version: '2.0.8'
    compileOnly fileTree(dir: "$runtimeLibs")
}

sourceSets {
    main {
        java {
            srcDirs = ["src/CommunityCommons/javasource"]
        }
        resources {
            srcDirs = ["src/CommunityCommons/resources"]
        }
    }
}

task copyToUserlib( type: Copy ) {
    into userLibDir
    from configurations.runtime
}

distributions {
    main {
        baseName = 'CommunityCommons'
        contents {
            into('/') {
                from 'src/CommunityCommons'
                exclude('**/proxies/*')
                exclude('**/system/*')
            }
            into('/') {
                from 'package.xml'
            }
        }
    }
}

distZip {
    archiveName "$baseName-$version" + ".mpk"
}


task fullDist {
    dependsOn 'clean', 'copyToUserlib', 'packageXML', 'distZip'
}

clean {
    delete "$projectDir/src/CommunityCommons/userlib"
    delete "$projectDir/package.xml"
}

task packageXML {
    ext.interpolateFileElementXML = { resource ->
        return "<file path=\"${resource}\" />"
    }

    ext.buildRelativePath = { fileEntry, directory ->
        return (fileEntry.absolutePath - directory.absolutePath).replace("/", "\\").substring(1)
    }

    ext.getResources = {
        def list = []
        def userLibDirectory = file(userLibDir)

        def distributionCopySpec = distributions.main.contents.buildRootResolver().allSource

        distributionCopySpec.each { f ->
            list << interpolateFileElementXML(buildRelativePath(f, file("$projectDir/src/CommunityCommons")))
        }

        return list
    }

    doLast {
        def packageXMLResources = getResources()
        def packageXML = new XmlParser().parseText(packageXMLTemplate)

        packageXMLResources.each { resource ->
            def resourceXML = new XmlParser().parseText(resource)
            packageXML.modelerProject.files[0].append(resourceXML)
        }

        String out = XmlUtil.serialize( packageXML )
        new File("$projectDir/package.xml").write(out)
    }

    tasks.distZip.shouldRunAfter tasks.packageXML
    tasks.packageXML.shouldRunAfter tasks.copyToUserlib
}